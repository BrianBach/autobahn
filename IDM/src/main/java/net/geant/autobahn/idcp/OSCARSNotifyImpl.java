/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package net.geant.autobahn.idcp;

import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import org.apache.log4j.Logger;
import javax.jws.Oneway;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import net.geant.autobahn.reservation.Reservation;

import org.apache.cxf.ws.addressing.AttributedURIType;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import org.apache.cxf.ws.addressing.ReferenceParametersType;
import org.oasis_open.docs.wsn.b_2.FilterType;
import org.oasis_open.docs.wsn.b_2.NotificationMessageHolderType;
import org.oasis_open.docs.wsn.b_2.RenewResponse;
import org.oasis_open.docs.wsn.b_2.SubscribeResponse;
import org.oasis_open.docs.wsn.b_2.TopicExpressionType;
import org.oasis_open.docs.wsn.b_2.UnsubscribeResponse;

/**
 * This class was generated by Apache CXF 2.4.2 2011-08-30T10:58:32.466+02:00
 * Generated source version: 2.4.2
 * 
 */

@javax.jws.WebService(serviceName = "OSCARSNotify", portName = "OSCARSNotify", targetNamespace = "http://oscars.es.net/OSCARS", wsdlLocation = "file:etc/wsdl/IDCP/OSCARS-Notify.wsdl", endpointInterface = "net.geant.autobahn.idcp.OSCARSNotify")
public class OSCARSNotifyImpl implements OSCARSNotify {

	private Logger log = Logger.getLogger(this.getClass());

	public static final String TOPIC_IDC = "idc:IDC";
	public static final String TOPIC_INFO = "idc:INFO";
	public static final String TOPIC_DEBUG = "idc:DEBUG";
	public static final String TOPIC_ERROR = "idc:ERROR";
	public static final String TOPIC_DIALECT = "http://docs.oasis-open.org/wsn/t-1/TopicExpression/Full";
	public static final String QUERY_DIALECT = "http://www.w3.org/TR/1999/REC-xpath-19991116";

	public static final int MAX_SUBSCRIPTION_TIME = 1; // in hours

	private EndpointReferenceType createEndpoint(String consumerUrl, String subscriptionId, String publisherId) {

		EndpointReferenceType endpoint = new EndpointReferenceType();
		endpoint.setMetadata(null);
		AttributedURIType address = new AttributedURIType();
		address.setValue(consumerUrl);
		endpoint.setAddress(address);
		ReferenceParametersType ref = new ReferenceParametersType();
		ref.setSubscriptionId(subscriptionId);
		ref.setPublisherRegistrationId(publisherId);
		endpoint.setReferenceParameters(ref);

		return endpoint;
	}

	private void printEndpoint(EndpointReferenceType endpoint) {

		log.info("consumerUrl: "
				+ endpoint.getAddress().getValue()
				+ ", subId: "
				+ endpoint.getReferenceParameters().getSubscriptionId()
				+ ", pubId: "
				+ endpoint.getReferenceParameters()
						.getPublisherRegistrationId());
	}

	private XMLGregorianCalendar toXmlCalendar(Date time) {

		try {
			GregorianCalendar cal = new GregorianCalendar();
			cal.setTime(time);
			return DatatypeFactory.newInstance().newXMLGregorianCalendar(cal);
		} catch (Exception e) {
			log.info("could not create xml calendar from Date - "
					+ time.toString());
			return null;
		}
	}

	private XMLGregorianCalendar toXmlCalendar(String time) {

		try {
			return DatatypeFactory.newInstance().newXMLGregorianCalendar(time);
		} catch (Exception e) {
			log.info("could not create xml calendar from String - " + time);
			return null;
		}
	}

	private void eventToReservationState(Reservation resv, String event) {

		// switch reservation's state based on incoming state
		// there are two ACTIVATING and FINISHING events (depending on
		// whether home or last domain reports, only one event is used

		if (event.compareTo("RESERVATION_CREATE_CONFIRMED") == 0)
			resv.setState(4); // SCHEDULING
		else if (event.compareTo("RESERVATION_CREATE_COMPLETED") == 0)
			resv.setState(5); // SCHEDULED
		else if (event.compareTo("DOWNSTREAM_PATH_SETUP_CONFIRMED") == 0)
			resv.setState(9); // ACTIVATING
		else if (event.compareTo("PATH_SETUP_COMPLETED") == 0)
			resv.setState(10); // ACTIVE
		else if (event.compareTo("DOWNSTREAM_PATH_CONFIRMED") == 0)
			resv.setState(11); // FINISHING
		else if (event.compareTo("PATH_TEARDOWN_COMPLETED") == 0)
			resv.setState(21); // FINISHED
		else if (event.compareTo("RESERVATION_CANCEL_CONFIRMED") == 0)
			resv.setState(6); // CANCELLING
		else if (event.compareTo("RESERVATION_CANCEL_COMPLETED") == 0)
			resv.setState(22); // CANCELLED
		else
			resv.setState(23); // FAILED

		// FAILED events are: RESERVATION_CREATE_FAILED,
		// RESERVATION_CANCEL_FAILED, PATH_SETUP_FAILED,
		// PATH_TEARDOWN_FAILED
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#subscribe(org.oasis_open.docs.wsn
	 * .b_2.Subscribe subscribeRequest )*
	 */
	public org.oasis_open.docs.wsn.b_2.SubscribeResponse subscribe(org.oasis_open.docs.wsn.b_2.Subscribe subscribeRequest)
			throws InvalidMessageContentExpressionFault, UnsupportedPolicyRequestFault,	InvalidProducerPropertiesExpressionFault,
			UnacceptableInitialTerminationTimeFault, UnrecognizedPolicyRequestFault, ResourceUnknownFault, TopicNotSupportedFault, 
			NotifyMessageNotSupportedFault, InvalidFilterFault, TopicExpressionDialectUnknownFault,
			AAAFaultMessage, InvalidTopicExpressionFault, SubscribeCreationFailedFault {

		log.info("subscribe received");

		// CONSUMER
		EndpointReferenceType consumer = subscribeRequest
				.getConsumerReference();
		// printEndpoint(consumer);
		String subscriptionId = consumer.getReferenceParameters()
				.getSubscriptionId();
		final String publisherId = consumer.getReferenceParameters()
				.getPublisherRegistrationId();
		final String consumerUrl = consumer.getAddress().getValue();

		System.out.println("subscription - " + subscriptionId
				+ ", consumerUrl - " + consumerUrl);

		// TERMINATION
		// final JAXBElement<String> termination =
		// subscribeRequest.getInitialTerminationTime();
		// log.info("termination - " + termination.getValue() + ", qname - " +
		// termination.getName());
		// final String term = termination.getValue();

		// TOPIC
		FilterType filter = subscribeRequest.getFilter();
		if (filter == null) {
			log.info("filter not found");
			throw new InvalidFilterFault("filter not found");
		}

		if (filter.getTopicExpression().size() > 1)
			log.info("multiple topics defined");

		TopicExpressionType topicExpression = filter.getTopicExpression()
				.get(0);
		log.info("topic - " + topicExpression.getValue() + ", dialect - "
				+ topicExpression.getDialect());

		if (!topicExpression.getDialect().equals(TOPIC_DIALECT))
			throw new TopicExpressionDialectUnknownFault();

		if (!topicExpression.getValue().equals(TOPIC_IDC))
			throw new TopicNotSupportedFault("only topic " + TOPIC_IDC
					+ " supported");

		final String topic = topicExpression.getValue();

		// POLICY
		if (subscribeRequest.getSubscriptionPolicy() != null) {
			log.info("subscribe policy defined but not used");
			throw new UnsupportedPolicyRequestFault("policy not supported");
		}

		SubscribeResponse response = new SubscribeResponse();
		response.setCurrentTime(toXmlCalendar(Calendar.getInstance().getTime()));
		// response.setTerminationTime(toXmlCalendar(term));
		response.setCurrentTime(null);

		// check subId, and generate new one if needed
		if (subscriptionId == null)
			subscriptionId = IdcpManager.generateSubscriptionId();

		final String notifierUrl = IdcpManager.getNotifyServiceUrl();
		SubscriptionInfo subInfo = new SubscriptionInfo(consumerUrl,
				notifierUrl, notifierUrl, subscriptionId, publisherId, topic,
				null);
		IdcpManager.addSubscriber(subInfo);
		response.setSubscriptionReference(createEndpoint(notifierUrl,
				subscriptionId, publisherId));
		return response;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#resumeSubscription(org.oasis_open
	 * .docs.wsn.b_2.ResumeSubscription resumeSubscriptionRequest )*
	 */
	public org.oasis_open.docs.wsn.b_2.ResumeSubscriptionResponse resumeSubscription(org.oasis_open.docs.wsn.b_2.ResumeSubscription resumeSubscriptionRequest)
			throws ResourceUnknownFault, ResumeFailedFault, AAAFaultMessage {

		log.info("resumeSubscription - not supported");
		throw new ResumeFailedFault("not supported");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#registerPublisher(org.oasis_open
	 * .docs.wsn.br_2.RegisterPublisher registerPublisherRequest )*
	 */
	public org.oasis_open.docs.wsn.br_2.RegisterPublisherResponse registerPublisher(org.oasis_open.docs.wsn.br_2.RegisterPublisher registerPublisherRequest)
			throws PublisherRegistrationRejectedFault,	UnacceptableInitialTerminationTimeFault, ResourceUnknownFault,
			PublisherRegistrationFailedFault, TopicNotSupportedFault, InvalidTopicExpressionFault {

		log.info("registerPublisher - not supported");
		throw new PublisherRegistrationFailedFault("not supported");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#unsubscribe(org.oasis_open.docs.
	 * wsn.b_2.Unsubscribe unsubscribeRequest )*
	 */
	public org.oasis_open.docs.wsn.b_2.UnsubscribeResponse unsubscribe(org.oasis_open.docs.wsn.b_2.Unsubscribe unsubscribeRequest)
			throws UnableToDestroySubscriptionFault, ResourceUnknownFault, AAAFaultMessage {

		log.info("unsubscribe received");
		EndpointReferenceType endpoint = unsubscribeRequest
				.getSubscriptionReference();
		printEndpoint(endpoint);

		// find subscription
		final String consumerUrl = endpoint.getAddress().getValue();
		final String subscriptionId = endpoint.getReferenceParameters()
				.getSubscriptionId();

		SubscriptionInfo subInfo = IdcpManager.findSubscriber(consumerUrl,
				subscriptionId);
		if (subInfo == null) {
			log.info("subscription " + subscriptionId
					+ " not found, throwing an exception");
			throw new UnableToDestroySubscriptionFault("subscription "
					+ subscriptionId + " not found");
		}

		// remove
		IdcpManager.removeSubscriber(subInfo);
		log.info("subscription " + subscriptionId + " removed");
		UnsubscribeResponse response = new UnsubscribeResponse();
		response.setSubscriptionReference(createEndpoint(
				subInfo.getNotifierUrl(), subInfo.getSubscriptionId(),
				subInfo.getPublisherId()));
		return response;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#pauseSubscription(org.oasis_open
	 * .docs.wsn.b_2.PauseSubscription pauseSubscriptionRequest )*
	 */
	public org.oasis_open.docs.wsn.b_2.PauseSubscriptionResponse pauseSubscription(org.oasis_open.docs.wsn.b_2.PauseSubscription pauseSubscriptionRequest)
			throws PauseFailedFault, ResourceUnknownFault, AAAFaultMessage {

		log.info("pauseSubscription - not supported");
		throw new PauseFailedFault("not supported");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#renew(org.oasis_open.docs.wsn.b_2
	 * .Renew renewRequest )*
	 */
	public org.oasis_open.docs.wsn.b_2.RenewResponse renew(org.oasis_open.docs.wsn.b_2.Renew renewRequest)
			throws ResourceUnknownFault, UnacceptableTerminationTimeFault, AAAFaultMessage {

		log.info("renew message received");

		EndpointReferenceType endpoint = renewRequest
				.getSubscriptionReference();
		final String consumerUrl = endpoint.getAddress().getValue();
		final String subscriptionId = endpoint.getReferenceParameters()
				.getSubscriptionId();

		final String termination = renewRequest.getTerminationTime();

		// find
		SubscriptionInfo subInfo = IdcpManager.findSubscriber(consumerUrl,
				subscriptionId);
		if (subInfo == null) {
			log.info("subscription " + subscriptionId + " not found");
			throw new ResourceUnknownFault("subscription " + subscriptionId
					+ " not found");
		}

		// set new time

		RenewResponse response = new RenewResponse();
		response.setCurrentTime(toXmlCalendar(Calendar.getInstance().getTime()));
		response.setTerminationTime(null);
		response.setSubscriptionReference(createEndpoint(
				subInfo.getNotifierUrl(), subInfo.getSubscriptionId(),
				subInfo.getPublisherId()));
		return response;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#notify(org.oasis_open.docs.wsn.b_2
	 * .Notify notify )*
	 */
	public void notify(org.oasis_open.docs.wsn.b_2.Notify notify) {

		log.info("notify message received");

		try {

			for (NotificationMessageHolderType notification : notify
					.getNotificationMessage()) {

				for (EventContent event : notification.getMessage().getEvent()) {

					// find reservation
					String resId = event.getResDetails()
							.getGlobalReservationId();
					System.out.println("Notify - resId: " + resId);
					// Reservation resv =
					// AccessPoint.getInstance().getAutobahnReservation(resId);

				}
			}
		} catch (Exception ex) {
			log.info("Notify Exception - " + ex.getMessage());
			ex.printStackTrace();
			throw new RuntimeException(ex);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * net.geant.autobahn.idcp.OSCARSNotify#destroyRegistration(org.oasis_open
	 * .docs.wsn.br_2.DestroyRegistration destroyRegistrationRequest )*
	 */
	public org.oasis_open.docs.wsn.br_2.DestroyRegistrationResponse destroyRegistration(org.oasis_open.docs.wsn.br_2.DestroyRegistration destroyRegistrationRequest)
			throws ResourceUnknownFault, ResourceNotDestroyedFault,	AAAFaultMessage {

		log.info("destroyRegistration - not supported");
		throw new ResourceUnknownFault("not supported");
	}
}
